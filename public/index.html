<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess God - Multi Session</title>
    <style>
        :root {
            --primary: #c9a66b;
            --danger: #ff4d4d;
            --warning: #ffcc00;
            --bg: #0a0a0a;
            --glass: rgba(255, 255, 255, 0.07);
            --glass-border: rgba(255, 255, 255, 0.15);
            --board-dark: #1a1a1a;
            --board-light: #222222;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg); 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            color: white;
            touch-action: none;
        }

        /* Splash Screen Styles */
        #splash-screen {
            position: fixed;
            inset: 0;
            background-color: #050505;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease-out;
            overflow: hidden;
        }

        #splash-bg {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            /* Remove grid-template-rows: repeat(8, 1fr) to let squares define the height */
            opacity: 0.1;
            z-index: -1;
            overflow: hidden; /* Prevents overflow if squares exceed screen height */
        }

        .bg-square {
            width: 100%;
            aspect-ratio: 1 / 1; /* This ensures the height always matches the width */
        }
        .bg-square.dark { background-color: #111; }
        .bg-square.light { background-color: #333; }

        #splash-content {
            text-align: center;
            animation: fadeIn 1.5s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        #splash-image {
            width: min(320px, 80vw);
            height: auto;
            margin-bottom: 2rem;
            filter: drop-shadow(0 0 20px rgba(201, 166, 107, 0.3));
            border-radius: 15px;
        }

        .initializing-text {
            margin-top: 1.5rem;
            font-size: 0.75rem;
            letter-spacing: 0.25rem;
            color: var(--primary);
            font-weight: 500;
            text-transform: uppercase;
        }

        .loader {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(201, 166, 107, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.20);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            /* backdrop-filter: blur(12px); */
            padding: 20px;
        }

        .modal-box {
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--glass-border);
            padding: 30px;
            border-radius: 20px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            /* box-shadow: 0 25px 60px rgba(0,0,0,0.6); */
            animation: modalPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes modalPop {
            from { transform: scale(0.85); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-box h2 { margin-top: 0; letter-spacing: 2px; font-size: 1.4rem; color: var(--primary); }
        .modal-box p { color: #aaa; margin-bottom: 25px; font-size: 0.9rem; line-height: 1.6; }
        
        .close-btn {
            background: var(--glass);
            color: white;
            border: 1px solid var(--glass-border);
            padding: 12px 35px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            letter-spacing: 1px;
            width: 100%;
        }
        .close-btn:hover { background: rgba(255,255,255,0.1); border-color: white; }

        #game-ui {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        #header-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
            width: 90%;
            max-width: 280px;
        }

        #turn-indicator {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            padding: 12px 15px;
            border-radius: 30px;
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            text-align: center;
            width: 80%;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        .turn-w { color: white; border-bottom: 3px solid white !important; }
        .turn-b { color: var(--primary); border-bottom: 3px solid var(--primary) !important; }
        .check-alert { color: var(--danger) !important; border-bottom: 3px solid var(--danger) !important; animation: pulse 1s infinite; }

        #reset-btn {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 8px 18px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }
        #reset-btn:hover { background: rgba(255,255,255,0.15); border-color: white; }

        #info-trigger {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.3);
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            width: 80%;
        }

        .credits-grid {
            text-align: left;
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 10px;
            font-size: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
        }
        .credits-grid b { color: var(--primary); font-weight: 600; text-transform: uppercase; font-size: 0.65rem; }


        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        @media (max-width: 500px) {
            #info-trigger { top: auto; bottom: 20px; right: 20px; }
            #controls-hint { bottom: 70px; }
        }
    </style>
</head>
<body>

<div id="splash-screen">
    <div id="splash-bg"></div>
    <div id="splash-content">
        <img id="splash-image" src="splash.png" alt="Chess God" onerror="this.style.display='none'">
        <div class="loader"></div>
        <div class="initializing-text">Polishing the Board...</div>
    </div>
</div>

<div id="info-modal" class="modal-overlay">
    <div class="modal-box">
        <div style="font-size: 0.6rem; color: var(--danger); margin-bottom: 10px; font-weight: 800; letter-spacing: 3px; text-transform: uppercase;">Beta Version 1.0</div>
        <h2>CHESS GOD</h2>
        
        <div class="credits-grid">
            <b>Dev:</b> <span>Geovert John D. Labita</span>
            <b>Art:</b> <span>Jerson D. Labita</span>
            <b>Team:</b> <span>Joeniño Cainday, James Bañas, James Yugo, Denzel Saraus, Ella Dacapio, Iggy Carpio, Joesant Cordova, John Parba, Joss Opeña, Karl Gutierrez, Keely Englatiera, Vesley Amper, Kirk Vellecera, Ralph Lumigue</span>
        </div>

        <div style="margin-top: 25px;">
            <button class="close-btn" onclick="closeModal('info-modal')">BACK TO GAME</button>
        </div>
    </div>
</div>

<div id="move-error-modal" class="modal-overlay">
    <div class="modal-box" style="border-color: var(--warning);">
        <h2 style="color: var(--warning);">INVALID ACTION</h2>
        <p id="move-error-msg">The move you attempted was rejected by the server.</p>
        <button class="close-btn" style="background: rgba(255, 204, 0, 0.1); border-color: var(--warning);" onclick="window.resetGame(); closeModal('move-error-modal');">RESET GAME</button>
    </div>
</div>

<div id="error-modal" class="modal-overlay">
    <div class="modal-box" style="border-color: var(--danger);">
        <h2 style="color: var(--danger);">ENGINE ERROR</h2>
        <p id="error-msg">Connection to the session was lost.</p>
        <button class="close-btn" style="background: var(--danger);" onclick="location.reload()">RELOAD PAGE</button>
    </div>
</div>

<div id="game-ui">
    <div id="header-controls">
        <div id="turn-indicator" class="turn-w">WHITE'S TURN</div>
        <button id="reset-btn">Reset Match</button>
    </div>
    <div id="info-trigger" onclick="openModal('info-modal')">?</div>
    <div id="controls-hint">DRAG TO ROTATE • PINCH TO ZOOM • TAP PIECES</div>
</div>

<div id="game-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.js"></script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import * as TWEEN_Module from 'three/addons/libs/tween.module.min.js';
    const TWEEN = TWEEN_Module.TWEEN || TWEEN_Module.default || TWEEN_Module;

    const API_BASE = "http://localhost:3000";
    const BOARD_SIZE = 8;
    const TILE_SIZE = 4;
    const BOARD_OFFSET = (BOARD_SIZE * TILE_SIZE) / 2 - (TILE_SIZE / 2);
    
    const COLORS = {
        whiteTile: 0xE8E3C9, blackTile: 0x4A3728,
        whitePiece: 0xFFFFFF, blackPiece: 0x222222,
        validMove: 0x4FC3F7, captureMove: 0xFF5252,
        kingCheck: 0xFF1744
    };

    let scene, camera, renderer, controls, raycaster, mouse;
    let game = new Chess();
    let boardMap = {}; 
    let tiles = []; 
    let pieces = []; 
    let selectedPiece = null;
    let validMoves = [];
    let animationRunning = false;
    let isGameOver = false;

    window.openModal = (id) => document.getElementById(id).style.display = 'flex';
    window.closeModal = (id) => document.getElementById(id).style.display = 'none';

    function showMoveError(msg) {
        document.getElementById('move-error-msg').innerText = msg;
        openModal('move-error-modal');
    }

    function createSplashBackground() {
        const container = document.getElementById('splash-bg');
        for (let i = 0; i < 64; i++) {
            const square = document.createElement('div');
            const row = Math.floor(i / 8);
            const col = i % 8;
            square.className = (row + col) % 2 === 0 ? 'bg-square light' : 'bg-square dark';
            container.appendChild(square);
        }
    }

    async function initializeGame() {
        createSplashBackground();
        try {
            const res = await fetch(`${API_BASE}/moves`, { credentials: 'include' });
            if (!res.ok) throw new Error("Could not fetch game state");
            const data = await res.json();
            
            if (data.movesHistory && data.movesHistory.length > 0) {
                for (const moveStr of data.movesHistory) {
                    const from = moveStr.substring(0, 2).toLowerCase();
                    const to = moveStr.substring(2, 4).toLowerCase();
                    game.move({ from, to, promotion: 'q' });
                }
                loadPiecesFromFEN(game.fen());
            }
        } catch (e) { 
            console.warn("Session error, starting clean.", e); 
        } finally {
            updateStatusUI();
            const splash = document.getElementById('splash-screen');
            setTimeout(() => {
                splash.style.opacity = '0';
                setTimeout(() => splash.style.display = 'none', 1000);
            }, 800);
        }
    }

    async function sendMoveToServer(from, to) {
        const el = document.getElementById('turn-indicator');
        updateStatusUI();
        if(isGameOver) return; 

        await new Promise(r => setTimeout(r, 800));
        el.innerText = "BLACK IS ANALYZING...";
        el.className = 'turn-b';

        try {
            const response = await fetch(`${API_BASE}/move`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ from, to })
            });
            
            const data = await response.json();
            
            if (!response.ok || data.error) { 
                showMoveError(data.error || "Engine error"); 
                game.undo();
                loadPiecesFromFEN(game.fen());
                updateStatusUI();
                return; 
            }

            if (data.ai_from && data.ai_to) {
                const bFrom = data.ai_from[0].toLowerCase();
                const bTo = data.ai_to[0].toLowerCase();
                const p3d = boardMap[bFrom];

                // Logic: Validate AI move against local engine rules
                const possibleAiMoves = game.moves({ square: bFrom, verbose: true });
                const isValidAiMove = possibleAiMoves.some(m => m.to === bTo);

                if (p3d && isValidAiMove) {
                    executeMove(p3d, { from: bFrom, to: bTo });
                } else {
                    console.error("Engine provided illegal move:", bFrom, bTo);
                    showMoveError(`Engine provided illegal move: ${bFrom} ${bTo}`);
                }
            }
        } catch (e) { 
            updateStatusUI(); 
            showMoveError("Network error: Sync failed.");
            game.undo();
            loadPiecesFromFEN(game.fen());
        }
    }

    window.resetGame = async () => {
        try { await fetch(`${API_BASE}/reset`, { method: 'POST', credentials: 'include' }); } catch (e) {}
        game = new Chess();
        loadPiecesFromFEN(game.fen());
        updateStatusUI();
        deselect();
        isGameOver = false;
    }

    function algebraicToCoords(square) {
        return { x: square.charCodeAt(0) - 'a'.charCodeAt(0), z: parseInt(square[1], 10) - 1 };
    }
    function coordsToAlgebraic(x, z) {
        return String.fromCharCode('a'.charCodeAt(0) + x) + (z + 1);
    }
    function get3DPosition(x, z) {
        return { x: x * TILE_SIZE - BOARD_OFFSET, y: 0, z: z * TILE_SIZE - BOARD_OFFSET };
    }

    function getPieceGeometry(type) {
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.6, 0.5, 32), mat);
        base.position.y = 0.25; 
        group.add(base);

        let mesh;
        if (type === 'p') {
            mesh = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 16), mat); mesh.position.y = 1.5; group.add(mesh);
            const h = new THREE.Mesh(new THREE.SphereGeometry(0.8), mat); h.position.y = 2.5; group.add(h);
        } else if (type === 'r') {
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 3), mat); mesh.position.y = 2; group.add(mesh);
            const t = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), mat); t.position.y = 3.5; group.add(t);
        } else if (type === 'n') {
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 2), mat); mesh.position.y = 1.5; group.add(mesh);
            const h = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 2), mat); h.position.set(0, 3, 0.2); h.rotation.x = -0.5; group.add(h);
        } else if (type === 'b') {
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 3.5), mat); mesh.position.y = 2.25; group.add(mesh);
            const s = new THREE.Mesh(new THREE.SphereGeometry(0.4), mat); s.position.y = 4.5; group.add(s);
        } else if (type === 'q') {
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.3, 4), mat); mesh.position.y = 2.5; group.add(mesh);
            const c = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.5, 10), mat); c.position.y = 4.6; group.add(c);
        } else if (type === 'k') {
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.4, 5), mat); mesh.position.y = 3; group.add(mesh);
            const v = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), mat); v.position.y = 6; group.add(v);
        }
        
        group.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
        const hitbox = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 1.8, 7, 8), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
        hitbox.position.y = 3.5; hitbox.userData = { isHitbox: true }; group.add(hitbox);
        return group;
    }

    function createPiece(type, color, square) {
        const { x, z } = algebraicToCoords(square);
        const group = getPieceGeometry(type);
        const mat = new THREE.MeshStandardMaterial({ color: color === 'w' ? COLORS.whitePiece : COLORS.blackPiece, roughness: 0.2, metalness: 0.1 });
        group.traverse(c => { 
            if(c.isMesh && !c.userData.isHitbox) c.material = mat; 
            if(c.userData.isHitbox) c.userData.parentGroup = group; 
        });
        const pos = get3DPosition(-x+7, z);
        group.position.set(pos.x, 0, pos.z);
        group.userData = { type, color, square };
        if (color === 'b') group.rotation.y = Math.PI;
        scene.add(group);
        pieces.push(group);
        boardMap[square] = group;
    }

    function loadPiecesFromFEN(fen) {
        pieces.forEach(p => scene.remove(p));
        pieces = []; boardMap = {};
        const b = game.board();
        for (let r = 0; r < 8; r++) {
            for (let f = 0; f < 8; f++) {
                const p = b[r][f];
                if (p) createPiece(p.type, p.color, coordsToAlgebraic(f, 7-r));
            }
        }
    }

    function executeMove(piece, move) {
        // Double Check: Validating move legality right before execution
        const legalMoves = game.moves({ square: move.from, verbose: true });
        const isLegal = legalMoves.some(m => m.to === move.to);

        if (!isLegal) {
            console.error("Illegal move execution blocked:", move);
            showMoveError("Illegal move blocked by logic engine.");
            deselect();
            return;
        }

        animationRunning = true;
        const result = game.move({ from: move.from, to: move.to, promotion: 'q' });
        
        const { x, z } = algebraicToCoords(result.to);
        const targetPos = get3DPosition(-x+7, z);
        const targetPiece = boardMap[result.to];

        if (targetPiece && targetPiece !== piece) {
            pieces = pieces.filter(p => p !== targetPiece);
            delete boardMap[result.to];
            new TWEEN.Tween(targetPiece.position).to({ y: -10 }, 400).onComplete(() => scene.remove(targetPiece)).start();
        }

        // Handle Castling or Special Moves (Reload to ensure correct placement)
        if (result.flags.includes('k') || result.flags.includes('q') || result.flags.includes('e')) {
            loadPiecesFromFEN(game.fen()); 
            animationRunning = false;
            updateStatusUI();
            if (result.color === 'w') sendMoveToServer(result.from, result.to);
            deselect();
            return;
        }

        delete boardMap[result.from];
        piece.userData.square = result.to;
        boardMap[result.to] = piece;

        new TWEEN.Tween(piece.position).to({ x: targetPos.x, z: targetPos.z }, 500).easing(TWEEN.Easing.Cubic.Out).onComplete(() => {
            animationRunning = false;
            updateStatusUI();
            if (result.color === 'w') sendMoveToServer(result.from, result.to);
        }).start();
        deselect();
    }

    function onPointerDown(event) {
        if (animationRunning || isGameOver || game.turn() !== 'w') return;
        const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
        const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([...pieces, ...tiles], true);
        let hitPiece = null, hitTile = null;
        for (const intersect of intersects) {
            let cur = intersect.object;
            while(cur) {
                if(cur.userData.parentGroup) { hitPiece = cur.userData.parentGroup; break; }
                if(cur.userData.type) { hitPiece = cur; break; }
                cur = cur.parent;
            }
            if(hitPiece) break;
            if(intersect.object.userData.isTile) { hitTile = intersect.object; break; }
        }
        if (hitPiece && hitPiece.userData.color === 'w') {
            selectPiece(hitPiece);
        } else if (selectedPiece) {
            let target = null;
            if (hitPiece && hitPiece.userData.color !== 'w') target = hitPiece.userData.square;
            else if (hitTile) target = coordsToAlgebraic(-hitTile.userData.x + 7, hitTile.userData.z);
            
            // Check if selected destination is in validMoves
            const move = validMoves.find(m => m.to === target);
            if (move) executeMove(selectedPiece, move);
            else deselect();
        }
    }

    function selectPiece(p) {
        deselect();
        selectedPiece = p; p.position.y = 0.5;
        validMoves = game.moves({ square: p.userData.square, verbose: true });
        updateHighlights();
    }

    function deselect() {
        if (selectedPiece) selectedPiece.position.y = 0;
        selectedPiece = null; validMoves = [];
        updateHighlights();
    }

    function updateHighlights() {
        tiles.forEach(t => {
            const isWhite = (t.userData.x + t.userData.z) % 2 === 0;
            t.material.color.setHex(isWhite ? COLORS.whiteTile : COLORS.blackTile);
            t.material.emissive.setHex(0x000000);
        });
        if(game.in_check()) {
            const sq = pieces.find(p3d => p3d.userData.type === 'k' && p3d.userData.color === game.turn())?.userData.square;
            if (sq) {
                const {x, z} = algebraicToCoords(sq);
                const t = tiles.find(tile => tile.userData.x === (-x + 7) && tile.userData.z === z);
                if (t) t.material.emissive.setHex(COLORS.kingCheck);
            }
        }
        validMoves.forEach(m => {
            const { x, z } = algebraicToCoords(m.to);
            const t = tiles.find(tile => tile.userData.x === (-x + 7) && tile.userData.z === z);
            if (t) t.material.emissive.setHex(m.captured ? COLORS.captureMove : COLORS.validMove);
        });
    }

    function updateStatusUI() {
        const el = document.getElementById('turn-indicator');
        el.classList.remove('check-alert');
        if (game.in_checkmate()) {
            isGameOver = true;
            el.innerText = `CHECKMATE! ${game.turn() === 'w' ? 'BLACK' : 'WHITE'} WINS`;
            el.className = 'check-alert';
        } else if (game.in_draw()) {
            isGameOver = true;
            el.innerText = "DRAW";
        } else {
            const turn = game.turn();
            el.innerText = (turn === 'w' ? "WHITE" : "BLACK") + "'S TURN" + (game.in_check() ? " (CHECK)" : "");
            el.className = turn === 'w' ? 'turn-w' : 'turn-b';
            if(game.in_check()) el.classList.add('check-alert');
        }
        updateHighlights();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.fov = camera.aspect < 1 ? 70 : 45;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function init() {
        scene = new THREE.Scene(); 
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 40, 120);

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(aspect < 1 ? 70 : 45, aspect, 1, 1000);
        camera.position.set(0, 60, -5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 20;
        controls.maxDistance = 80;

        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const spotLight = new THREE.SpotLight(0xffffff, 1200);
        spotLight.position.set(20, 50, 20);
        spotLight.castShadow = true;
        scene.add(spotLight);
        scene.add(new THREE.PointLight(0xc9a66b, 400));

        const tileGeo = new THREE.BoxGeometry(TILE_SIZE, 0.8, TILE_SIZE);
        for (let x = 0; x < 8; x++) {
            for (let z = 0; z < 8; z++) {
                const tile = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ 
                    color: (x+z)%2===0 ? COLORS.whiteTile : COLORS.blackTile,
                    roughness: 0.7, metalness: 0.1
                }));
                const pos = get3DPosition(x, z); 
                tile.position.set(pos.x, -0.4, pos.z);
                tile.receiveShadow = true;
                tile.userData = { isTile: true, x, z }; 
                scene.add(tile); 
                tiles.push(tile);
            }
        }

        raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        document.getElementById('reset-btn').addEventListener('click', window.resetGame);
        window.addEventListener('resize', onWindowResize);

        loadPiecesFromFEN(game.fen());
        initializeGame();

        function animate(t) { requestAnimationFrame(animate); TWEEN.update(t); controls.update(); renderer.render(scene, camera); }
        animate();
    }
    window.onload = init;
</script>
</body>
</html>