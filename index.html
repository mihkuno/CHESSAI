<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chess with Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { width: 100vw; height: 100vh; display: block; }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 1.2rem;
            pointer-events: none;
            text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            user-select: none;
            min-width: 250px;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            pointer-events: none;
            user-select: none;
        }
        /* Added simple loading screen for better UX */
        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 100;
        }
        .status-check {
            color: #ff5555;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="loading-screen">Loading 3D Chess...</div>

<div id="ui-layer">
    <div id="status-text">White's Turn</div>
</div>
<div id="controls-hint">Left Click: Select/Move | Right Click: Rotate | Scroll: Zoom</div>
<div id="game-container"></div>

<!-- Import map for Three.js and OrbitControls -->
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<!-- Load chess.js for game logic -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.js"></script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    
    // Fix for TWEEN import error: use namespace import and extract TWEEN object
    import * as TWEEN_Module from 'three/addons/libs/tween.module.min.js';
    const TWEEN = TWEEN_Module.TWEEN || TWEEN_Module.default || TWEEN_Module;

    // --- Configuration ---
    const BOARD_SIZE = 8;
    const TILE_SIZE = 4;
    const BOARD_OFFSET = (BOARD_SIZE * TILE_SIZE) / 2 - (TILE_SIZE / 2);
    
    // Colors
    const COLORS = {
        whiteTile: 0xE8E3C9, // Cream (Light)
        blackTile: 0x5C4033, // Dark Wood (Dark)
        whitePiece: 0xFFFFFF,
        blackPiece: 0x333333,
        highlight: 0x66FF66,
        selected: 0xFFFF66,
        validMove: 0x00A0F0, // Blue for moves (Subtle Emissive)
        captureMove: 0xF00000 // Red for captures (Subtle Emissive)
    };

    // --- Game State ---
    let scene, camera, renderer, controls, raycaster, mouse;
    let game = null; // chess.js instance
    let boardMap = {}; // Maps algebraic square ('a1') to 3D piece object
    let tiles = []; // Array of mesh objects for tiles
    let pieces = []; // Array of piece meshes
    let selectedPiece = null;
    let validMoves = []; // Array of chess.js move objects
    let animationRunning = false;
    let isGameOver = false;

    // --- Utility Functions ---
    // Converts chess algebraic notation ('a1') to 3D board coordinates (x, z)
    function algebraicToCoords(square) {
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0); // 0=A, 7=H
        const rank = parseInt(square[1], 10) - 1; // 0=rank 1, 7=rank 8
        return { x: file, z: rank };
    }

    // Converts 3D board coordinates (x, z) to chess algebraic notation ('a1')
    function coordsToAlgebraic(x, z) {
        const file = String.fromCharCode('a'.charCodeAt(0) + x);
        const rank = z + 1;
        return file + rank;
    }

    // Gets the 3D position from grid coordinates
    function get3DPosition(x, z) {
        return {
            x: x * TILE_SIZE - BOARD_OFFSET,
            y: 0,
            z: z * TILE_SIZE - BOARD_OFFSET
        };
    }

    // --- Piece Definitions (Geometries) ---
    const PIECE_GEOMETRY_CACHE = {};

    function getPieceGeometry(type) {
        if (PIECE_GEOMETRY_CACHE[type]) return PIECE_GEOMETRY_CACHE[type];

        const group = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Color set later

        // Base for all pieces
        const baseGeo = new THREE.CylinderGeometry(1.4, 1.6, 0.5, 32);
        const base = new THREE.Mesh(baseGeo, material);
        base.position.y = 0.25;
        base.castShadow = true;
        group.add(base);

        // Simple Geometric Shapes for Pieces
        if (type === 'p') { // Pawn
            const body = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 16), material);
            body.position.y = 1.5;
            body.castShadow = true;
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), material);
            head.position.y = 2.5;
            head.castShadow = true;
            group.add(head);
        } else if (type === 'r') { // Rook
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 3, 16), material);
            body.position.y = 2;
            body.castShadow = true;
            group.add(body);
            const top = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), material);
            top.position.y = 3.5;
            top.castShadow = true;
            group.add(top);
        } else if (type === 'n') { // Knight
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 2, 16), material);
            body.position.y = 1.5;
            body.castShadow = true;
            group.add(body);
            // Simple horse head shape using a manipulated box/cylinder
            const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 2), material);
            head.position.set(0, 3, 0.2);
            head.rotation.x = -Math.PI / 6;
            head.castShadow = true;
            group.add(head);
        } else if (type === 'b') { // Bishop
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 3.5, 16), material);
            body.position.y = 2.25;
            body.castShadow = true;
            group.add(body);
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.4), material);
            ball.position.y = 4.5;
            group.add(ball);
        } else if (type === 'q') { // Queen (Taller, Spikier Crown)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.3, 4, 16), material);
            body.position.y = 2.5;
            body.castShadow = true;
            group.add(body);
            
            // Crown (Spiky look)
            const crownGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 10, 1, false);
            const crown = new THREE.Mesh(crownGeo, material);
            crown.position.y = 4.6;
            crown.castShadow = true;
            group.add(crown);
            
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.4), material);
            ball.position.y = 5.0;
            group.add(ball);

        } else if (type === 'k') { // King (Tallest, prominent cross)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.4, 5, 16), material);
            body.position.y = 3;
            body.castShadow = true;
            group.add(body);
            
            // Cross (more prominent)
            const v = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), material);
            v.position.y = 6.0;
            group.add(v);
            const h = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 0.5), material);
            h.position.y = 6.0;
            group.add(h);
        }

        // --- IMPROVED HITBOX GENERATION ---
        // Determine specific height for hitbox based on piece type to prevent
        // "invisible towers" blocking tiles behind pieces when camera is tilted.
        let hitboxHeight = 4;
        let hitboxRadius = 1.6; // Slightly tighter than 1.8 to avoid overlap
        
        if (type === 'p') hitboxHeight = 3.2; // Pawn is small
        else if (type === 'r' || type === 'n') hitboxHeight = 4.0;
        else if (type === 'b') hitboxHeight = 4.8;
        else if (type === 'q') hitboxHeight = 5.5;
        else if (type === 'k') hitboxHeight = 6.5;

        // Use transparent/opacity 0 instead of visible:false to ensure reliable raycasting
        const hitbox = new THREE.Mesh(
            new THREE.CylinderGeometry(hitboxRadius, hitboxRadius, hitboxHeight, 8),
            new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false }) 
        );
        
        // Position hitbox so it covers the piece from the base up
        hitbox.position.y = hitboxHeight / 2; 
        hitbox.userData = { isHitbox: true };
        group.add(hitbox);

        PIECE_GEOMETRY_CACHE[type] = group;
        return group; 
    }

    function createPiece(type, color, square) {
        const { x, z } = algebraicToCoords(square);
        const template = getPieceGeometry(type);
        const pieceGroup = template.clone(); // Clone the group structure
        
        // Traverse and clone materials to set correct color
        const matColor = color === 'w' ? COLORS.whitePiece : COLORS.blackPiece;
        const mat = new THREE.MeshStandardMaterial({ 
            color: matColor, 
            roughness: 0.3,
            metalness: 0.4 
        });

        pieceGroup.traverse((child) => {
            if (child.isMesh && !child.userData.isHitbox) {
                child.material = mat;
            }
            if (child.userData.isHitbox) {
                // Link hitbox back to the group
                child.userData.parentGroup = pieceGroup;
            }
        });

        // Set initial position
        // BUG FIX: Applied -x + 7 for correct Piece positioning
        const pos3D = get3DPosition(-x+7, z);
        pieceGroup.position.set(pos3D.x, 0, pos3D.z);

        // Metadata
        pieceGroup.userData = {
            type: type, // 'p', 'r', 'n', 'b', 'q', 'k'
            color: color, // 'w' or 'b'
            square: square, // 'a1', 'h8', etc.
            algebraic: square // For raycasting identification
        };

        // Rotate black pieces to face white
        if (color === 'b') {
            pieceGroup.rotation.y = Math.PI;
        }

        scene.add(pieceGroup);
        pieces.push(pieceGroup);
        boardMap[square] = pieceGroup;
    }

    // --- Game Logic ---
    function initGameState() {
        // Clear existing pieces
        pieces.forEach(p => scene.remove(p));
        pieces = [];
        boardMap = {};
        isGameOver = false;

        // Initialize chess.js game (starts at standard FEN)
        game = new Chess();

        // Create 3D pieces based on initial FEN
        loadPiecesFromFEN(game.fen());
        
        // Ensure starting rotation is for White (0 degrees)
        // Set camera to White's perspective (behind negative Z ranks)
        controls.target.set(0, 0, 0);
        camera.position.set(0, 50, -25); // Initial position for White's view (negative Z)
        controls.update();

        updateStatusText();
    }

    function loadPiecesFromFEN(fen) {
        const board = game.board();
        
        // Clear existing 3D objects
        pieces.forEach(p => scene.remove(p));
        pieces = [];
        boardMap = {};

        // Iterate through the 8x8 board from chess.js
        for (let r = 0; r < 8; r++) { // Ranks 8 down to 1 (array index 0 down to 7)
            for (let f = 0; f < 8; f++) { // Files A through H (array index 0 through 7)
                const piece = board[r][f];
                if (piece) {
                    // Convert file/rank index (f, r) to algebraic square ('a8', 'h1')
                    // Rank 7 is '1', Rank 0 is '8'
                    const algebraicRank = 8 - r;
                    const algebraicFile = String.fromCharCode('a'.charCodeAt(0) + f);
                    const square = algebraicFile + algebraicRank;
                    
                    createPiece(piece.type, piece.color, square);
                }
            }
        }
    }

    function createBoard() {
        const boardGroup = new THREE.Group();
        
        // Wood texture base (simple box)
        const borderGeo = new THREE.BoxGeometry(BOARD_SIZE * TILE_SIZE + 2, 1, BOARD_SIZE * TILE_SIZE + 2);
        const borderMat = new THREE.MeshStandardMaterial({ color: 0x3d2b1f, roughness: 0.8 });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.y = -0.5;
        border.receiveShadow = true;
        boardGroup.add(border);

        const tileGeo = new THREE.BoxGeometry(TILE_SIZE, 0.5, TILE_SIZE);

        for (let x = 0; x < BOARD_SIZE; x++) {
            for (let z = 0; z < BOARD_SIZE; z++) {
                
                // (0,0) A1 is Dark. This is determined by (x+z) % 2 === 0
                // Corrected logic: (x+z) % 2 === 0 -> White square
                const isWhiteSquare = (x + z) % 2 === 0;
                
                const material = new THREE.MeshStandardMaterial({
                    color: isWhiteSquare ? COLORS.whiteTile : COLORS.blackTile,
                    roughness: 0.5,
                    metalness: 0.1
                });
                
                const tile = new THREE.Mesh(tileGeo, material);
                const pos3D = get3DPosition(x, z);
                tile.position.set(pos3D.x, 0, pos3D.z);
                tile.receiveShadow = true;
                
                // Store metadata in the mesh for raycasting
                const square = coordsToAlgebraic(x, z);
                tile.userData = { isTile: true, x: x, z: z, algebraic: square };
                
                boardGroup.add(tile);
                tiles.push(tile);
            }
        }
        scene.add(boardGroup);
    }

    // --- Interaction ---
    function onPointerDown(event) {
        if (animationRunning || isGameOver) return;

        // Ensure we only process left clicks
        if (event.button !== 0) return;

        // Calculate mouse position
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // --- IMPROVED RAYCASTING ---
        // Combine all interactable objects (Pieces and Tiles) into one list.
        // This allows Raycaster to sort by distance properly.
        // If a piece is visually in front of a tile, the piece is hit first.
        // If a tile is visually in front of a piece (or behind an empty space of a piece), the tile is hit.
        const interactables = [...pieces, ...tiles];
        const intersects = raycaster.intersectObjects(interactables, true);

        let clickedPiece = null;
        let clickedTile = null;

        // Iterate through intersections sorted by distance (closest first)
        for (let i = 0; i < intersects.length; i++) {
            const obj = intersects[i].object;
            
            // Check if we hit a piece (or its hitbox/children)
            // Traverse up to find the group with userData
            let current = obj;
            let foundPiece = null;
            
            while (current) {
                if (current.userData && current.userData.type) {
                    foundPiece = current;
                    break;
                }
                if (current.userData && current.userData.parentGroup) {
                    foundPiece = current.userData.parentGroup; // Shortcut via hitbox
                    break;
                }
                current = current.parent;
            }

            if (foundPiece) {
                clickedPiece = foundPiece;
                break; // Found the closest valid object (a piece), stop processing
            }

            // Check if we hit a tile
            if (obj.userData && obj.userData.isTile) {
                clickedTile = obj;
                break; // Found the closest valid object (a tile), stop processing
            }
        }
        
        let targetSquare = null;

        // Logic Implementation
        if (clickedPiece && clickedPiece.userData.color === game.turn()) {
            // 1. Selecting a piece of the current turn color
            selectPiece(clickedPiece);
        } else if (selectedPiece) {
            // 2. A piece is already selected, try to move
            if (clickedPiece && clickedPiece.userData.color !== game.turn()) {
                // Clicking an enemy piece (Capture intent)
                targetSquare = clickedPiece.userData.square;
            } else if (clickedTile) {
                // Clicking a tile
                // Correct derivation of target square from clicked tile coordinates:
                const tx = clickedTile.userData.x;
                const tz = clickedTile.userData.z;
                
                // Inverse of -x+7 is -(x-7) => -x+7.
                // So if visual x is 7, logical x is -7+7 = 0 ('a').
                const logicalX = -tx + 7;
                targetSquare = coordsToAlgebraic(logicalX, tz);

            } else {
                deselect();
                return;
            }

            // Check if valid move using algebraic notation
            const move = validMoves.find(m => m.to === targetSquare);
            if (move) {
                executeMove(selectedPiece, move);
            } else {
                // If clicked an enemy piece that's not a valid target, try to select it
                if (clickedPiece && clickedPiece.userData.color !== game.turn()) {
                    deselect();
                } else {
                    deselect(); // Invalid move deselects
                }
            }
        } else {
            // Nothing to do
            deselect();
        }
    }

    function selectPiece(piece) {
        if (selectedPiece === piece) {
            // Clicked the same piece, deselect it
            deselect();
            return;
        }

        if (selectedPiece) {
            // Reset previous selection visuals
            selectedPiece.position.y = 0; 
        }

        selectedPiece = piece;
        // Visual feedback (hop up)
        piece.position.y = 0.5;

        // Get valid moves from chess.js
        validMoves = game.moves({ square: piece.userData.square, verbose: true });
        
        // Highlight tiles
        updateHighlights();
    }

    function deselect() {
        if (selectedPiece) {
            selectedPiece.position.y = 0;
            selectedPiece = null;
        }
        validMoves = [];
        updateHighlights();
    }

    function updateHighlights() {
        // Reset all tiles
        tiles.forEach(t => {
            // Check if the square is A1 (0,0). A1 is Dark.
            const isWhiteSquare = (t.userData.x + t.userData.z) % 2 === 0;
            t.material.color.setHex(isWhiteSquare ? COLORS.whiteTile : COLORS.blackTile);
            t.material.emissive.setHex(0x000000); // Remove emissive highlight
        });

        // Highlight valid moves
        validMoves.forEach(m => {
            const { x, z } = algebraicToCoords(m.to);
            // BUG FIX: Highlight the tile at the inverted visual position
            // Logical x goes to visual -x+7
            const t = tiles.find(tile => tile.userData.x === (-x + 7) && tile.userData.z === z);
            if (t) {
                // Use emissive color for moves
                const color = m.captured || m.flags.includes('c') || m.flags.includes('e') ? COLORS.captureMove : COLORS.validMove;
                t.material.emissive.setHex(color);
            }
        });
        
        // Highlight selected piece tile
        if (selectedPiece) {
            const { x, z } = algebraicToCoords(selectedPiece.userData.square);
            // BUG FIX: Highlight the tile at the inverted visual position
            const t = tiles.find(tile => tile.userData.x === (-x + 7) && tile.userData.z === z);
            // Subtle yellow highlight on the tile the selected piece is on
            if(t) t.material.emissive.setHex(0x222200);

            // Highlight King in check
            if (game.in_check()) {
                 const kingSquare = getKingSquare();
                 if (kingSquare) {
                    const { x: kx, z: kz } = algebraicToCoords(kingSquare);
                    // BUG FIX: Highlight the tile at the inverted visual position
                    const kingTile = tiles.find(tile => tile.userData.x === (-kx + 7) && tile.userData.z === kz);
                    if(kingTile) kingTile.material.emissive.setHex(0x500000); // Dark Red for check
                 }
            }
        }
    }

    function getKingSquare() {
        // Find the king of the current player's color
        const color = game.turn();
        const board = game.board();
        for (let r = 0; r < 8; r++) {
            for (let f = 0; f < 8; f++) {
                const piece = board[r][f];
                if (piece && piece.type === 'k' && piece.color === color) {
                    const algebraicRank = 8 - r;
                    const algebraicFile = String.fromCharCode('a'.charCodeAt(0) + f);
                    return algebraicFile + algebraicRank;
                }
            }
        }
        return null;
    }

    function executeMove(piece, move) {
        animationRunning = true;
        
        // 1. Execute move in chess.js logic
        const executedMove = game.move(move);

        if (!executedMove) {
            console.error("Move failed in chess.js. This should not happen.");
            animationRunning = false;
            deselect();
            return;
        }

        // 2. Handle 3D piece movement and capture
        const { x, z } = algebraicToCoords(executedMove.to);
        // BUG FIX: Target position uses -x+7
        const targetPos = get3DPosition(-x+7, z); 
        
        // Find piece at the target square (if it exists) before the piece moves
        const targetPiece = boardMap[executedMove.to];
        
        if (targetPiece) {
            // Remove captured piece from the list of interactable pieces
            pieces = pieces.filter(p => p !== targetPiece);
            delete boardMap[executedMove.to];

            // Animate captured piece sinking and moving out of the way
            new TWEEN.Tween(targetPiece.position)
                .to({ y: -10, x: targetPiece.position.x + 30 * Math.random() - 15, z: targetPiece.position.z + 30 * Math.random() - 15 }, 400)
                .easing(TWEEN.Easing.Quadratic.In)
                .onComplete(() => {
                    scene.remove(targetPiece);
                })
                .start();
        }
        
        // Handle castling (Rook movement)
        if (executedMove.flags.includes('k') || executedMove.flags.includes('q')) {
            const rookMove = getCastlingRookMove(executedMove);
            if (rookMove) {
                const rook = boardMap[rookMove.from];
                const { x: rx, z: rz } = algebraicToCoords(rookMove.to);
                // BUG FIX: Rook target position also uses -x+7
                const rookTargetPos = get3DPosition(-rx+7, rz);

                new TWEEN.Tween(rook.position)
                    .to({ x: rookTargetPos.x, z: rookTargetPos.z }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                // Update map for rook
                rook.userData.square = rookMove.to;
                boardMap[rookMove.to] = rook;
                delete boardMap[rookMove.from];
            }
        }
        
        // Handle promotion
        if (executedMove.promotion) {
            // Remove the pawn
            scene.remove(piece);
            pieces = pieces.filter(p => p !== piece);
            delete boardMap[executedMove.from];
            
            // Create the new Queen (or other promoted piece)
            createPiece(executedMove.promotion, executedMove.color, executedMove.to);
            piece = boardMap[executedMove.to]; // Update piece reference to the new Queen
        }

        // Update piece data
        delete boardMap[executedMove.from];
        piece.userData.square = executedMove.to;
        piece.userData.algebraic = executedMove.to;
        boardMap[executedMove.to] = piece;

        // Animate piece movement
        new TWEEN.Tween(piece.position)
            .to({ x: targetPos.x, z: targetPos.z }, 500)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                piece.position.y = 0;
                animationRunning = false;
                switchTurn();
            })
            .start();

        deselect();
    }
    
    // Helper to find the rook movement in a castling move
    function getCastlingRookMove(executedMove) {
        if (executedMove.flags.includes('k') || executedMove.flags.includes('q')) {
            const color = executedMove.color;
            const rank = color === 'w' ? '1' : '8';

            // Kingside Castling (e1 -> g1, h1 -> f1)
            if (executedMove.to === 'g' + rank) {
                return { from: 'h' + rank, to: 'f' + rank };
            }
            // Queenside Castling (e1 -> c1, a1 -> d1)
            if (executedMove.to === 'c' + rank) {
                return { from: 'a' + rank, to: 'd' + rank };
            }
        }
        return null;
    }


    function updateStatusText() {
        const statusEl = document.getElementById('status-text');
        
        if (game.game_over()) {
            isGameOver = true;
            if (game.in_checkmate()) {
                const winner = game.turn() === 'w' ? 'Black' : 'White';
                statusEl.innerHTML = `<span class="status-check">${winner} Wins by CHECKMATE!</span>`;
            } else {
                statusEl.innerHTML = `<span class="status-check">Game Over: Draw by ${
                    game.in_stalemate() ? 'Stalemate' : 
                    game.in_threefold_repetition() ? 'Threefold Repetition' : 
                    game.insufficient_material() ? 'Insufficient Material' : '50-Move Rule'
                }</span>`;
            }
        } else {
            const turn = game.turn() === 'w' ? 'White' : 'Black';
            let text = `${turn}'s Turn`;
            if (game.in_check()) {
                text += ` <span class="status-check">(CHECK!)</span>`;
            }
            statusEl.innerHTML = text;
        }
    }

    function switchTurn() {
        const currentTurn = game.turn();
        updateStatusText();
        
        // Auto-Rotation Logic
        let targetPosition, targetLookAt;

        if (currentTurn === 'w') {
            // White's turn: Camera behind Rank 1 (Negative Z)
            targetPosition = new THREE.Vector3(0, 50, -25);
        } else {
            // Black's turn: Camera behind Rank 8 (Positive Z)
            targetPosition = new THREE.Vector3(0, 50, 25);
        }
        
        // Always look at the center of the board
        targetLookAt = new THREE.Vector3(0, 0, 0);

        // Tween the camera position and the controls target (which is where the camera looks)
        new TWEEN.Tween(camera.position)
            .to(targetPosition, 800)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .start();

        new TWEEN.Tween(controls.target)
            .to(targetLookAt, 800)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .onUpdate(() => {
                controls.update();
            })
            .start();
    }


    // --- Standard Boilerplate ---
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time); // Update TWEEN animations
        controls.update();
        renderer.render(scene, camera);
    }

    function init() {
        // 1. Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 20, 100);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, -25); // Initial position for White's view (negative Z)
        
        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        document.getElementById('loading-screen').style.display = 'none';

        // 4. Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2; 
        controls.minDistance = 20;
        controls.maxDistance = 80;
        controls.target.set(0, 0, 0); // Always look at center
        controls.update();

        // 5. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xffeedd, 0.3);
        fillLight.position.set(-20, 20, -20);
        scene.add(fillLight);

        // 6. Interaction
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('pointerdown', onPointerDown);

        // 7. Initialize Game Objects
        createBoard();
        initGameState();

        // 8. Animation Loop
        animate();
    }

    // Start
    window.onload = function() {
        init();
    };

</script>
</body>
</html>