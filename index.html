<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess God</title>
    <style>
        :root {
            --primary: #c9a66b;
            --danger: #ff4d4d;
            --bg: #0a0a0a;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --board-dark: #1a1a1a;
            --board-light: #222222;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg); 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            color: white;
        }

        /* --- Improved Splash Screen --- */
        #splash-screen {
            position: fixed;
            inset: 0;
            background-color: #050505;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease-out;
            overflow: hidden;
        }

        #splash-bg {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            opacity: 0.15;
            z-index: -1;
        }

        .bg-square { width: 100%; height: 100%; }
        .bg-square.dark { background-color: #333; }
        .bg-square.light { background-color: #555; }

        #splash-content {
            text-align: center;
            animation: fadeIn 1.5s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        #splash-image {
            width: 320px;
            height: auto;
            margin-bottom: 2rem;
            filter: drop-shadow(0 0 20px rgba(201, 166, 107, 0.3));
            border-radius: 15px;
        }

        .initializing-text {
            margin-top: 1.5rem;
            font-size: 1rem;
            letter-spacing: 0.2rem;
            color: var(--primary);
            font-weight: 500;
            text-transform: uppercase;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(201, 166, 107, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* --- Custom Error Modal --- */
        #error-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }

        .modal-box {
            background: #111;
            border: 1px solid var(--danger);
            padding: 40px;
            border-radius: 16px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 77, 77, 0.2);
            animation: modalPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes modalPop {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-box h2 { color: var(--danger); margin-top: 0; letter-spacing: 2px; }
        .modal-box p { color: #aaa; margin-bottom: 30px; font-size: 1rem; line-height: 1.5; }
        
        .reset-action-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: filter 0.2s;
        }
        .reset-action-btn:hover { filter: brightness(1.2); }

        /* --- Game UI Overlay --- */
        #game-ui {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        #top-left-info {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            max-width: 300px;
        }

        .disclaimer {
            font-size: 0.75rem;
            color: var(--danger);
            background: rgba(255, 77, 77, 0.1);
            padding: 4px 10px;
            border-radius: 4px;
            border-left: 3px solid var(--danger);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .credits-btn {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: rgba(255,255,255,0.6);
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        #credits-panel {
            display: none;
            margin-top: 10px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            font-size: 0.75rem;
            line-height: 1.4;
            color: rgba(255,255,255,0.8);
        }

        #turn-container {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #turn-indicator {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            padding: 12px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.3s;
            text-align: center;
            min-width: 250px;
        }

        .turn-w { color: white; border-bottom: 2px solid white !important; }
        .turn-b { color: var(--primary); border-bottom: 2px solid var(--primary) !important; }
        .check-alert { color: var(--danger) !important; border-bottom: 2px solid var(--danger) !important; animation: pulse 1s infinite; }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #reset-btn {
            pointer-events: auto;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.5);
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.3);
            font-size: 0.75rem;
        }

        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        #game-container { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>

<div id="splash-screen">
    <div id="splash-bg"></div>
    <div id="splash-content">
        <img id="splash-image" src="splash.png" alt="Chess God" onerror="this.style.display='none'">
        <div class="loader"></div>
        <div class="initializing-text">Initializing Board...</div>
    </div>
</div>

<div id="error-modal">
    <div class="modal-box">
        <h2 id="error-title">AI LOGIC ERROR</h2>
        <p id="error-msg">The Black AI attempted an illegal move or encountered a synchronization failure.</p>
        <button class="reset-action-btn" onclick="resetGame()">Reset Game Session</button>
    </div>
</div>

<div id="game-ui">
    <div id="top-left-info">
        <div class="disclaimer">Disclaimer: This game is a beta app. Updates and full features coming in the next version.</div>
        <button class="credits-btn" onclick="toggleCredits()">View Credits</button>
        <div id="credits-panel">
            <p><strong>Programmer:</strong> Geovert John D. Labita</p>
            <p><strong>Cover Page:</strong> Jerson D. Labita</p>
            <p><strong>UI/UX:</strong> Joeniño D. Cainday, James Barrion Bañas, James Xander A. Yugo, Denzel Saraus, Ella Norienne Dacapio, Iggy Carpio, Joesant Cordova, John Vincent Parba, Joss Opeña, Karl Andre Gutierrez, Keely Shay Englatiera, Vesley Amper, Kirk Tajura Vellecera, Ralph Rhey Abao Lumigue</p>
        </div>
    </div>

    <div id="turn-container">
        <div id="turn-indicator" class="turn-w">WHITE'S TURN</div>
        <button id="reset-btn">Reset Board</button>
    </div>

    <div id="controls-hint">Orbit: Right Click | Pan: Shift + Right Click | Move: Left Click</div>
</div>

<div id="game-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.js"></script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import * as TWEEN_Module from 'three/addons/libs/tween.module.min.js';
    const TWEEN = TWEEN_Module.TWEEN || TWEEN_Module.default || TWEEN_Module;

    const API_BASE = "http://localhost:3000";
    const BOARD_SIZE = 8;
    const TILE_SIZE = 4;
    const BOARD_OFFSET = (BOARD_SIZE * TILE_SIZE) / 2 - (TILE_SIZE / 2);
    
    const COLORS = {
        whiteTile: 0xE8E3C9, blackTile: 0x5C4033,
        whitePiece: 0xFFFFFF, blackPiece: 0x333333,
        validMove: 0x00A0F0, captureMove: 0xF00000,
        kingCheck: 0xFF0000
    };

    let scene, camera, renderer, controls, raycaster, mouse;
    let game = new Chess();
    let boardMap = {}; 
    let tiles = []; 
    let pieces = []; 
    let selectedPiece = null;
    let validMoves = [];
    let animationRunning = false;
    let isGameOver = false;

    // --- UI Logic ---
    window.toggleCredits = () => {
        const p = document.getElementById('credits-panel');
        p.style.display = p.style.display === 'block' ? 'none' : 'block';
    };

    function showError(title, msg) {
        document.getElementById('error-title').innerText = title.toUpperCase();
        document.getElementById('error-msg').innerText = msg;
        document.getElementById('error-modal').style.display = 'flex';
    }

    function hideError() {
        document.getElementById('error-modal').style.display = 'none';
    }

    // Generate Splash BG
    const splashBg = document.getElementById('splash-bg');
    for (let i = 0; i < 64; i++) {
        const row = Math.floor(i / 8);
        const col = i % 8;
        const div = document.createElement('div');
        div.className = `bg-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
        splashBg.appendChild(div);
    }

    async function initializeGame() {
        try {
            const res = await fetch(`${API_BASE}/moves`);
            const data = await res.json();
            
            if (data.movesHistory && data.movesHistory.length > 0) {
                for (const moveStr of data.movesHistory) {
                    const from = moveStr.substring(0, 2).toLowerCase();
                    const to = moveStr.substring(2, 4).toLowerCase();
                    const p3d = boardMap[from];
                    if (p3d) {
                        await new Promise(resolve => {
                            game.move({ from, to, promotion: 'q' });
                            const { x, z } = algebraicToCoords(to);
                            const targetPos = get3DPosition(-x+7, z);
                            const targetPiece = boardMap[to];
                            if (targetPiece) {
                                scene.remove(targetPiece);
                                pieces = pieces.filter(p => p !== targetPiece);
                            }
                            delete boardMap[from];
                            p3d.position.set(targetPos.x, 0, targetPos.z);
                            p3d.userData.square = to;
                            boardMap[to] = p3d;
                            setTimeout(resolve, 100);
                        });
                    }
                }
            }
        } catch (e) {
            console.warn("New session starting.");
        } finally {
            updateStatusUI();
            setTimeout(() => {
                const splash = document.getElementById('splash-screen');
                splash.style.opacity = '0';
                setTimeout(() => splash.style.display = 'none', 1000);
            }, 500);
        }
    }

    async function sendMoveToServer(from, to) {
        const el = document.getElementById('turn-indicator');
        
        updateStatusUI();
        if(isGameOver) return; 

        await new Promise(r => setTimeout(r, 800));
        el.innerText = "BLACK IS THINKING...";
        el.classList.remove('check-alert');

        try {
            const response = await fetch(`${API_BASE}/move`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ from, to })
            });

            if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
            const data = await response.json();
            
            // CONSOLE LOG THE RESPONSE
            console.log("AI MOVE RESPONSE:", data);

            if (data.error) {
                showError("AI Engine Error", data.error);
                return;
            }

            if (data.ai_from && data.ai_from[0] && data.ai_to && data.ai_to[0]) {
                const blackFrom = data.ai_from[0].toLowerCase();
                const blackTo = data.ai_to[0].toLowerCase();
                const p3d = boardMap[blackFrom];
                
                // VALIDATE MOVE IN CHESS.JS LOCALLY BEFORE ANIMATING
                const testMove = new Chess(game.fen()).move({ from: blackFrom, to: blackTo, promotion: 'q' });
                
                if (!testMove) {
                    showError("Logic Error", `AI suggested an illegal move: ${blackFrom}${blackTo}.`);
                    return;
                }

                if (p3d) {
                    executeMove(p3d, { from: blackFrom, to: blackTo });
                } else {
                    showError("Sync Failure", `AI tried to move from ${blackFrom}, but no piece exists there.`);
                }
            } else {
                console.warn("No move returned from AI.");
                updateStatusUI();
            }
        } catch (e) {
            console.error("AI Fetch Failure:", e);
            showError("Network Connection Failed", "Unable to communicate with the Chess God server. Please check your connection.");
            updateStatusUI();
        }
    }

    window.resetGame = async () => {
        try {
            await fetch(`${API_BASE}/reset`, { method: 'POST' });
            game = new Chess();
            loadPiecesFromFEN(game.fen());
            updateStatusUI();
            deselect();
            hideError();
            isGameOver = false;
        } catch (e) {
            console.error("Reset failed", e);
            // Even if API fails, reset locally to allow play
            game = new Chess();
            loadPiecesFromFEN(game.fen());
            updateStatusUI();
            hideError();
        }
    }

    function algebraicToCoords(square) {
        const file = square.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square[1], 10) - 1;
        return { x: file, z: rank };
    }

    function coordsToAlgebraic(x, z) {
        return String.fromCharCode('a'.charCodeAt(0) + x) + (z + 1);
    }

    function get3DPosition(x, z) {
        return { x: x * TILE_SIZE - BOARD_OFFSET, y: 0, z: z * TILE_SIZE - BOARD_OFFSET };
    }

    const PIECE_GEOMETRY_CACHE = {};
    function getPieceGeometry(type) {
        if (PIECE_GEOMETRY_CACHE[type]) return PIECE_GEOMETRY_CACHE[type];
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.6, 0.5, 32), mat);
        base.position.y = 0.25; group.add(base);

        if (type === 'p') {
            const b = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 16), mat); b.position.y = 1.5; group.add(b);
            const h = new THREE.Mesh(new THREE.SphereGeometry(0.8), mat); h.position.y = 2.5; group.add(h);
        } else if (type === 'r') {
            const b = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 3), mat); b.position.y = 2; group.add(b);
            const t = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), mat); t.position.y = 3.5; group.add(t);
        } else if (type === 'n') {
            const b = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 2), mat); b.position.y = 1.5; group.add(b);
            const h = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 2), mat); h.position.set(0, 3, 0.2); h.rotation.x = -0.5; group.add(h);
        } else if (type === 'b') {
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 3.5), mat); b.position.y = 2.25; group.add(b);
            const s = new THREE.Mesh(new THREE.SphereGeometry(0.4), mat); s.position.y = 4.5; group.add(s);
        } else if (type === 'q') {
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.3, 4), mat); b.position.y = 2.5; group.add(b);
            const c = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.5, 10), mat); c.position.y = 4.6; group.add(c);
        } else if (type === 'k') {
            const b = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.4, 5), mat); b.position.y = 3; group.add(b);
            const v = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), mat); v.position.y = 6; group.add(v);
        }

        const hitbox = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 7, 8), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
        hitbox.position.y = 3.5; hitbox.userData = { isHitbox: true }; group.add(hitbox);
        PIECE_GEOMETRY_CACHE[type] = group;
        return group;
    }

    function createPiece(type, color, square) {
        const { x, z } = algebraicToCoords(square);
        const group = getPieceGeometry(type).clone();
        const mat = new THREE.MeshStandardMaterial({ color: color === 'w' ? COLORS.whitePiece : COLORS.blackPiece, roughness: 0.3, metalness: 0.4 });
        
        group.traverse(c => { 
            if(c.isMesh && !c.userData.isHitbox) c.material = mat; 
            if(c.userData.isHitbox) c.userData.parentGroup = group; 
        });

        const pos = get3DPosition(-x+7, z);
        group.position.set(pos.x, 0, pos.z);
        group.userData = { type, color, square };
        if (color === 'b') group.rotation.y = Math.PI;
        
        scene.add(group);
        pieces.push(group);
        boardMap[square] = group;
    }

    function loadPiecesFromFEN(fen) {
        pieces.forEach(p => scene.remove(p));
        pieces = []; boardMap = {};
        const b = game.board();
        for (let r = 0; r < 8; r++) {
            for (let f = 0; f < 8; f++) {
                const p = b[r][f];
                if (p) {
                    const sq = coordsToAlgebraic(f, 7-r);
                    createPiece(p.type, p.color, sq);
                }
            }
        }
    }

    function executeMove(piece, move) {
        animationRunning = true;
        const result = game.move({ from: move.from, to: move.to, promotion: 'q' });
        if (!result) { 
            animationRunning = false; 
            deselect();
            return; 
        }

        const { x, z } = algebraicToCoords(result.to);
        const targetPos = get3DPosition(-x+7, z);
        const targetPiece = boardMap[result.to];

        if (targetPiece && targetPiece !== piece) {
            pieces = pieces.filter(p => p !== targetPiece);
            delete boardMap[result.to];
            new TWEEN.Tween(targetPiece.position).to({ y: -10 }, 400).onComplete(() => scene.remove(targetPiece)).start();
        }

        // Handle Castling or Promotion by reloading everything if special flags met
        if (result.flags.includes('k') || result.flags.includes('q') || result.flags.includes('e')) {
            loadPiecesFromFEN(game.fen()); 
            animationRunning = false;
            updateStatusUI();
            if (result.color === 'w') sendMoveToServer(result.from, result.to);
            deselect();
            return;
        }

        delete boardMap[result.from];
        piece.userData.square = result.to;
        boardMap[result.to] = piece;

        new TWEEN.Tween(piece.position).to({ x: targetPos.x, z: targetPos.z }, 500).easing(TWEEN.Easing.Quadratic.Out).onComplete(() => {
            animationRunning = false;
            updateStatusUI();
            if (result.color === 'w') sendMoveToServer(result.from, result.to);
        }).start();
        deselect();
    }

    function onPointerDown(event) {
        if (animationRunning || isGameOver || event.button !== 0 || game.turn() !== 'w') return;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects([...pieces, ...tiles], true);
        let hitPiece = null, hitTile = null;

        for (const intersect of intersects) {
            let cur = intersect.object;
            while(cur) {
                if(cur.userData.parentGroup) { hitPiece = cur.userData.parentGroup; break; }
                if(cur.userData.type) { hitPiece = cur; break; }
                cur = cur.parent;
            }
            if(hitPiece) break;
            if(intersect.object.userData.isTile) { hitTile = intersect.object; break; }
        }

        if (hitPiece && hitPiece.userData.color === 'w') {
            selectPiece(hitPiece);
        } else if (selectedPiece) {
            let target = null;
            if (hitPiece && hitPiece.userData.color !== 'w') target = hitPiece.userData.square;
            else if (hitTile) target = coordsToAlgebraic(-hitTile.userData.x + 7, hitTile.userData.z);

            const move = validMoves.find(m => m.to === target);
            if (move) executeMove(selectedPiece, move);
            else deselect();
        }
    }

    function selectPiece(p) {
        deselect();
        selectedPiece = p; p.position.y = 0.5;
        validMoves = game.moves({ square: p.userData.square, verbose: true });
        updateHighlights();
    }

    function deselect() {
        if (selectedPiece) selectedPiece.position.y = 0;
        selectedPiece = null; validMoves = [];
        updateHighlights();
    }

    function updateHighlights() {
        tiles.forEach(t => {
            const isWhite = (t.userData.x + t.userData.z) % 2 === 0;
            t.material.color.setHex(isWhite ? COLORS.whiteTile : COLORS.blackTile);
            t.material.emissive.setHex(0x000000);
        });

        const board = game.board();
        if(game.in_check()) {
            const checkColor = game.turn();
            for(let r=0; r<8; r++) {
                for(let f=0; f<8; f++) {
                    const p = board[r][f];
                    if(p && p.type === 'k' && p.color === checkColor) {
                        const sq = coordsToAlgebraic(f, 7-r);
                        const {x, z} = algebraicToCoords(sq);
                        const t = tiles.find(tile => tile.userData.x === (-x + 7) && tile.userData.z === z);
                        if (t) t.material.emissive.setHex(COLORS.kingCheck);
                    }
                }
            }
        }

        validMoves.forEach(m => {
            const { x, z } = algebraicToCoords(m.to);
            const t = tiles.find(tile => tile.userData.x === (-x + 7) && tile.userData.z === z);
            if (t) t.material.emissive.setHex(m.captured ? COLORS.captureMove : COLORS.validMove);
        });
    }

    function updateStatusUI() {
        const el = document.getElementById('turn-indicator');
        el.classList.remove('check-alert');

        if (game.in_checkmate()) {
            isGameOver = true;
            const loserTurn = game.turn();
            const winner = loserTurn === 'w' ? 'BLACK' : 'WHITE';
            el.innerText = `CHECKMATE! ${winner} WINS`;
            el.className = loserTurn === 'w' ? 'turn-b check-alert' : 'turn-w check-alert';
        } else if (game.in_draw()) {
            isGameOver = true;
            el.innerText = "DRAW";
            el.className = '';
        } else {
            const turn = game.turn();
            const inCheck = game.in_check();
            el.innerText = (turn === 'w' ? "WHITE" : "BLACK") + "'S TURN" + (inCheck ? " (CHECK)" : "");
            el.className = turn === 'w' ? 'turn-w' : 'turn-b';
            if(inCheck) el.classList.add('check-alert');
        }
        updateHighlights();
    }

    function init() {
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a0a);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 50, -20);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        const light = new THREE.DirectionalLight(0xffffff, 1.2); light.position.set(10, 30, 10); scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        const tileGeo = new THREE.BoxGeometry(TILE_SIZE, 0.5, TILE_SIZE);
        for (let x = 0; x < 8; x++) {
            for (let z = 0; z < 8; z++) {
                const tile = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: (x+z)%2===0 ? COLORS.whiteTile : COLORS.blackTile }));
                const pos = get3DPosition(x, z); tile.position.set(pos.x, 0, pos.z);
                tile.userData = { isTile: true, x, z }; scene.add(tile); tiles.push(tile);
            }
        }

        raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        document.getElementById('reset-btn').addEventListener('click', window.resetGame);
        
        loadPiecesFromFEN(game.fen());
        initializeGame();

        function animate(t) { 
            requestAnimationFrame(animate); 
            TWEEN.update(t); 
            controls.update(); 
            renderer.render(scene, camera); 
        }
        animate();
    }

    window.onload = init;
</script>
</body>
</html>